{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC1820Registry.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using or updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC777.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {IERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` is made operator for `tokenHolder`.\n     */\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`.\n     */\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC777Recipient.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {IERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC777Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC777Sender.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n * their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {IERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "contracts/EthereumClaimsRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.20;\n\n/// @title Ethereum Claims Registry (ERC780)\ncontract EthereumClaimsRegistry {\n    mapping(address => mapping(address => mapping(bytes32 => bytes32))) private registry;\n\n    event ClaimSet(\n        address indexed issuer,\n        address indexed subject,\n        bytes32 indexed key,\n        bytes32 value,\n        uint updatedAt\n    );\n\n    event ClaimRemoved(\n        address indexed issuer,\n        address indexed subject,\n        bytes32 indexed key,\n        uint updatedAt\n    );\n\n    function getClaim(address issuer, address subject, bytes32 key) public view returns (bytes32) {\n        return registry[issuer][subject][key];\n    }\n\n    function setClaim(address subject, bytes32 key, bytes32 value) public {\n        registry[msg.sender][subject][key] = value;\n\n        emit ClaimSet(msg.sender, subject, key, value, block.timestamp);\n    }\n\n    function setSelfClaim(bytes32 key, bytes32 value) public {\n        setClaim(msg.sender, key, value);\n    }\n\n    function removeClaim(address issuer, address subject, bytes32 key) public {\n        address sender = msg.sender;\n        require(issuer == sender, \"Error: Claim issuer must be caller\");\n\n        delete registry[issuer][subject][key];\n\n        emit ClaimRemoved(issuer, subject, key, block.timestamp);\n    }\n}\n"
    },
    "contracts/EthereumDIDRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity ^0.8.20;\r\n\r\ncontract EthereumDIDRegistry {\r\n    // State variables\r\n    /// @dev Owner address => identity address\r\n    mapping(address => address) public owners;\r\n\r\n    /// @dev Owner address => unsigned integer\r\n    mapping(address => uint256) public nonce;\r\n\r\n    /// @dev identity => block number\r\n    mapping(address => uint256) public changed;\r\n\r\n    /// @dev identity => attribute => delegate => validity\r\n    mapping(address => mapping(bytes32 => mapping(address => uint256))) public delegates;\r\n\r\n    // Events\r\n    event DIDOwnerChanged(address indexed identity, address owner, uint previousChange);\r\n    event DIDDelegateChanged(\r\n        address indexed identity,\r\n        bytes32 delegateType,\r\n        address delegate,\r\n        uint256 validTo,\r\n        uint256 previousChange\r\n    );\r\n    event DIDAttributeChanged(\r\n        address indexed identity,\r\n        bytes32 name,\r\n        bytes value,\r\n        uint256 validTo,\r\n        uint previousChange\r\n    );\r\n\r\n    // Modifiers\r\n    modifier onlyOwner(address identity, address actor) {\r\n        require(actor == identityOwner(identity), \"Error: Owner only function\");\r\n        _;\r\n    }\r\n\r\n    // External\r\n    function changeOwner(address identity, address newOwner) external {\r\n        changeOwner(msg.sender, identity, newOwner);\r\n    }\r\n\r\n    function changeOwnerSigned(\r\n        address identity,\r\n        uint8 sigV,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        address newOwner\r\n    ) external {\r\n        bytes32 hash = keccak256(\r\n            abi.encodePacked(\r\n                bytes1(0x19),\r\n                bytes1(0),\r\n                address(this),\r\n                nonce[identityOwner(identity)],\r\n                identity,\r\n                \"changeOwner\",\r\n                newOwner\r\n            )\r\n        );\r\n        changeOwner(identity, checkSignature(identity, sigV, sigR, sigS, hash), newOwner);\r\n    }\r\n\r\n    function validDelegate(\r\n        address identity,\r\n        bytes32 delegateType,\r\n        address delegate\r\n    ) external view returns (bool) {\r\n        uint validity = delegates[identity][keccak256(abi.encodePacked(delegateType))][delegate];\r\n\r\n        return validity > block.timestamp;\r\n    }\r\n\r\n    function addDelegate(\r\n        address identity,\r\n        bytes32 delegateType,\r\n        address delegate,\r\n        uint256 validity\r\n    ) external {\r\n        addDelegate(identity, msg.sender, delegateType, delegate, validity);\r\n    }\r\n\r\n    function addDelegateSigned(\r\n        address identity,\r\n        uint8 sigV,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        bytes32 delegateType,\r\n        address delegate,\r\n        uint256 validity\r\n    ) external {\r\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0x19), bytes1(0), address(this), nonce[identityOwner(identity)], identity, \"addDelegate\", delegateType, delegate, validity));\r\n\r\n        addDelegate(identity, checkSignature(identity, sigV, sigR, sigS, hash), delegateType, delegate, validity);\r\n    }\r\n\r\n    function revokeDelegate(address identity, bytes32 delegateType, address delegate) external {\r\n        revokeDelegate(identity, msg.sender, delegateType, delegate);\r\n    }\r\n\r\n    function revokeDelegateSigned(address identity, uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32 delegateType, address delegate) external {\r\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0x19), bytes1(0), address(this), nonce[identityOwner(identity)], identity, \"revokeDelegate\", \r\n        delegateType, delegate));\r\n\r\n        revokeDelegate(identity, checkSignature(identity, sigV, sigR, sigS, hash), delegateType, delegate);\r\n    }\r\n\r\n    function setAttribute(address identity, bytes32 name, bytes calldata value, uint256 validity) external {\r\n        setAttribute(identity, msg.sender, name, value, validity);\r\n    }\r\n\r\n    function setAttributeSigned(address identity, uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32 name, bytes calldata value, uint256 validity) external {\r\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0x19), bytes1(0), address(this), nonce[identityOwner(identity)], identity, \"setAttribute\", name, value, validity));\r\n        setAttribute(identity, checkSignature(identity, sigV, sigR, sigS, hash), name, value, validity);\r\n    }\r\n\r\n    function revokeAttribute(address identity, bytes32 name, bytes calldata value) external {\r\n        revokeAttribute(identity, msg.sender, name, value);\r\n    }\r\n\r\n    function revokeAttributeSigned(address identity, uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32 name, bytes calldata value) external {\r\n        bytes32 hash = keccak256(abi.encodePacked(bytes1(0x19), bytes1(0), address(this), nonce[identityOwner(identity)], identity, \"revokeAttribute\", name, value));\r\n\r\n        revokeAttribute(identity, checkSignature(identity, sigV, sigR, sigS, hash), name, value);\r\n    }\r\n\r\n    // Public\r\n    function identityOwner(address identity) public view returns (address) {\r\n        address owner = owners[identity];\r\n        if (owner != address(0)) {\r\n            return owner;\r\n        }\r\n        return identity;\r\n    }\r\n\r\n    // Internal\r\n    function checkSignature(\r\n        address identity,\r\n        uint8 sigV,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        bytes32 hash\r\n    ) internal returns (address) {\r\n        address signer = ecrecover(hash, sigV, sigR, sigS);\r\n        require(signer == identityOwner(identity), \"Error: Signer is not Owner\");\r\n        nonce[signer]++;\r\n        return signer;\r\n    }\r\n\r\n    function changeOwner(\r\n        address identity,\r\n        address actor,\r\n        address newOwner\r\n    ) internal onlyOwner(actor, identity) {\r\n        owners[identity] = newOwner;\r\n\r\n        changed[identity] = block.number;\r\n    }\r\n\r\n    function addDelegate(\r\n        address identity,\r\n        address actor,\r\n        bytes32 delegateType,\r\n        address delegate,\r\n        uint256 validity\r\n    ) internal onlyOwner(identity, actor) {\r\n        delegates[identity][keccak256(abi.encodePacked(delegateType))][delegate] = validity + block.timestamp;\r\n        emit DIDDelegateChanged(\r\n            identity,\r\n            delegateType,\r\n            delegate,\r\n            validity + block.timestamp,\r\n            changed[identity]\r\n        );\r\n        changed[identity] = block.number;\r\n    }\r\n\r\n    function revokeDelegate(\r\n        address identity,\r\n        address actor,\r\n        bytes32 delegateType,\r\n        address delegate\r\n    ) internal onlyOwner(identity, actor) {\r\n        delegates[identity][keccak256(abi.encodePacked(delegateType))][delegate] = block.timestamp;\r\n        emit DIDDelegateChanged(\r\n            identity,\r\n            delegateType,\r\n            delegate,\r\n            block.timestamp,\r\n            changed[identity]\r\n        );\r\n        changed[identity];\r\n    }\r\n\r\n    function setAttribute(address identity, address actor, bytes32 name, bytes memory value, uint256 validity) internal onlyOwner(identity, actor){\r\n        emit DIDAttributeChanged(identity, name, value, validity + block.timestamp, changed[identity]);\r\n        changed[identity] = block.number;\r\n    }\r\n\r\n    function revokeAttribute(address identity, address actor, bytes32 name, bytes memory value) internal onlyOwner(identity, actor) {\r\n        emit DIDAttributeChanged(identity, name, value, block.timestamp, changed[identity]);\r\n        changed[identity] = block.number;\r\n    }\r\n}\r\n"
    },
    "contracts/ModifiedERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC777.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC777Sender.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/interfaces/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the `IERC777` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both `IERC777.Sent` and `IERC20.Transfer` events are emitted on token\n * movements.\n *\n * Additionally, the `granularity` value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\nabstract contract ModifiedERC777 is IERC777, IERC20 {\n    // Type declarations\n    using Math for uint256;\n    using Address for address;\n\n    // State variables\n    IERC1820Registry private _erc1820 =\n        IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    string private _name;\n    string private _symbol;\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n\n    /**\n     * @dev You can check these hashes using NodeJS by:\n     *   > const { keccak256 } = require('ethers')\n     *   > keccak256(Buffer.from(\"interface-to-hash\"))\n     */\n    // keccak256(\"ERC777TokensSender\")\n    bytes32 constant TOKENS_SENDER_INTERFACE_HASH =\n        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;\n\n    // keccak256(\"ERC777TokensRecipient\")\n    bytes32 constant TOKENS_RECIPIENT_INTERFACE_HASH =\n        0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b;\n\n    // This isn't ever read from\n    // It's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n    // Immutable, but accounts may revoke them for their own (check _revokedDefaultOperators)\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // Each account has its own list of accounts allowed to represent them\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    // Events\n\n    // Errors\n\n    // Modifiers\n    modifier onlyOperatorOf(address owner) {\n        require(isOperatorFor(owner, msg.sender), \"ERC777: Caller is not an operator for holder\");\n\n        _;\n    }\n\n    //constructor\n    /// @dev 'defaultOperator' may be an empty array.\n    constructor(\n        string memory tokenName,\n        string memory tokenSymbol,\n        address[] memory defaultOperatorsArray\n    ) {\n        _name = tokenName;\n        _symbol = tokenSymbol;\n\n        _defaultOperatorsArray = defaultOperatorsArray;\n        for (uint256 i = 0; i < defaultOperatorsArray.length; i++) {\n            _defaultOperators[defaultOperatorsArray[i]] = true;\n        }\n\n        // Register interface\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n        _erc1820.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n    }\n\n    // receive function (if exists)\n\n    // fallback function (if exists)\n\n    // external\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external onlyOperatorOf(sender) {\n        _send(msg.sender, sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external virtual {\n        _burn(msg.sender, msg.sender, amount, data, \"\");\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external onlyOperatorOf(account) {\n        _burn(msg.sender, account, amount, data, operatorData);\n    }\n\n    /**\n     * @notice Unlike burn, holder cannot mint token themselves\n     * @dev The rest is similar to operator burn, see `IERC777.operatorBurn`.\n     *\n     * Emits `Minted` and `Transfer` events.\n     */\n    function operatorMint(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external onlyOperatorOf(account) {\n        require(msg.sender != account, \"ERC777: Cannot mint for yourself\");\n        _mint(msg.sender, account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external virtual {\n        require(msg.sender != operator, \"ERC777: Cannot authorize self as an operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[msg.sender][operator];\n        } else {\n            _operators[msg.sender][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, msg.sender);\n    }\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external virtual {\n        require(operator != msg.sender, \"ERC777: Cannot revoke self as an operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[msg.sender][operator] = true;\n        } else {\n            delete _operators[msg.sender][operator];\n        }\n\n        emit RevokedOperator(operator, msg.sender);\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the name.\n     *\n     * See 'ERC777.symbol'\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     *\n     * See 'ERC777.totalSupply'\n     */\n    function totalSupply() external view override(IERC777, IERC20) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view override(IERC777, IERC20) returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     *\n     * See 'ERC777.granularity'\n     */\n    function granularity() external pure returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev The internal denomination is similar to a wei\n     * and the display denomination is similar to an ether (1 ETH = 1e18 WEI)\n     *\n     * See `ERC20Detailed.decimals`.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @notice Operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     *\n     * @return uint256 the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     *\n     * See 'ERC20.allowance'.\n     */\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external virtual returns (bool) {\n        _approve(msg.sender, spender, value);\n\n        return true;\n    }\n\n    // public\n    /**\n     * @dev Returns the name of the token.\n     *\n     * See 'ERC777.name'.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(address recipient, uint256 amount, bytes memory data) public virtual {\n        _send(msg.sender, msg.sender, recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * @notice Unlike `send`, `recipient` is _not_ required to implement the `tokensReceived`\n     * interface if it is a contract.\n     *\n     * @return bool indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     * See 'ERC20.transfer'.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        require(to.isNotZeroAddress(), \"ERC777: Recipient cannot be zero address\");\n\n        address from = msg.sender;\n\n        _callTokensToSend(from, from, to, value, \"\", \"\");\n\n        _move(from, from, to, value, \"\", \"\");\n\n        _callTokensReceived(from, from, to, value, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} and {Sent} event.\n     *\n     * See 'ERC20.transferFrom'\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        require(from.isNotZeroAddress(), \"ERC20: Tokens holder cannot be zero address\");\n        require(to.isNotZeroAddress(), \"ERC20: Tokens holder cannot be zero address\");\n\n        address spender = msg.sender;\n\n        _callTokensToSend(spender, from, to, value, \"\", \"\");\n\n        (bool success, uint256 result) = _allowances[from][spender].trySub(value);\n        require(success, \"ERC20: Insufficient allowance\");\n        _approve(from, spender, result);\n\n        _move(spender, from, to, value, \"\", \"\");\n\n        _callTokensReceived(spender, from, to, value, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address tokenHolder, address operator) public view returns (bool) {\n        return\n            tokenHolder == operator ||\n            _operators[tokenHolder][operator] ||\n            (_defaultOperators[operator] && _revokedDefaultOperators[tokenHolder][operator]);\n    }\n\n    // internal\n\n    // private\n    /**\n     * @dev Send tokens\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param data bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) private {\n        require(from.isNotZeroAddress(), \"ERC777: Sender cannot be zero address\");\n        require(to.isNotZeroAddress(), \"ERC777: Recipient cannot be zero address\");\n\n        _callTokensToSend(operator, from, to, amount, data, operatorData);\n\n        _move(operator, from, to, amount, data, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, data, operatorData, requireReceptionAck);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) private {\n        (bool success, uint256 result) = _balances[from].trySub(amount);\n        require(success, \"ERC777: Sender's balance is insufficient\");\n        _balances[from] = result;\n\n        (success, result) = _balances[to].tryAdd(amount);\n        require(success, \"ERC777: Recipient's balance overflowed\");\n        _balances[to] = result;\n\n        emit Transfer(from, to, amount);\n        emit Sent(operator, from, to, amount, data, operatorData);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param operator address operator requesting the operation\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address operator,\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) private {\n        require(from.isNotZeroAddress(), \"ERC777: Cannot burn from zero address\");\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        (bool success, uint256 result) = _balances[from].trySub(amount);\n        require(success, \"ERC777: Sender's balance is insufficient\");\n        _balances[from] = result;\n\n        (success, result) = _totalSupply.trySub(amount);\n        require(success, \"ERC777: Total supply is exhausted\");\n        _totalSupply = result;\n\n        emit Burned(operator, from, amount, data, operatorData);\n        /// @dev For ERC20 compatible\n        emit Transfer(from, address(0), amount);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See `IERC777Sender` and `IERC777Recipient`.\n     *\n     * Emits `Sent` and `Transfer` events.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     * - if `to` is a contract, it must implement the `tokensReceived` interface.\n     */\n    function _mint(\n        address operator,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) private {\n        require(to.isNotZeroAddress(), \"ERC777: Cannot mint to zero address\");\n\n        (bool success, uint256 result) = _balances[to].tryAdd(amount);\n        require(success, \"ERC777: Sender's balance overflowed\");\n        _balances[to] = result;\n\n        (success, result) = _totalSupply.tryAdd(amount);\n        require(success, \"ERC777: Total supply overflowed\");\n        _totalSupply = result;\n\n        _callTokensReceived(operator, address(0), to, amount, data, operatorData, true);\n\n        emit Minted(operator, to, amount, data, operatorData);\n        /// @dev For ERC20 compatible\n        emit Transfer(address(0), to, amount);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This private function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) private {\n        require(owner.isNotZeroAddress(), \"ERC20: Owner cannot be zero address\");\n        require(spender.isNotZeroAddress(), \"ERC20: Spender cannot be zero address\");\n\n        _allowances[owner][spender] = value;\n\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param data bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) private {\n        address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\n\n        if (implementer.isNotZeroAddress()) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, data, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param data bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) private {\n        address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\n\n        if (implementer.isNotZeroAddress()) {\n            IERC777Recipient(implementer).tokensReceived(\n                operator,\n                from,\n                to,\n                amount,\n                data,\n                operatorData\n            );\n        } else if (requireReceptionAck) {\n            require(\n                !to.isContract(),\n                \"ERC777: Tokens recipient contract has no implementer for ERC777TokensRecipient\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/NonTransferableERC777Token.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.20;\n\nimport \"./ModifiedERC777.sol\";\n\nabstract contract NonTransferableERC777Token is ModifiedERC777 {\n    event ForbiddenOperation(\n        string name,\n        address indexed operator,\n        address indexed recipient,\n        uint256 amount,\n        bytes data\n    );\n\n    constructor(\n        string memory tokenName,\n        string memory symbol,\n        address[] memory defaultOperators\n    ) ModifiedERC777(tokenName, symbol, defaultOperators) {}\n\n    // External\n    function send(address recipient, uint256 amount, bytes memory data) public override {\n        _revertOperation(\"send\", \"send\", msg.sender, recipient, amount, data);\n    }\n\n    function burn(uint256 amount, bytes calldata data) external override {\n        _revertOperation(\"burn\", \"burn\", msg.sender, address(0), amount, data);\n    }\n\n    function transfer(address to, uint256 value) public override returns (bool) {\n        _revertOperation(\"transfer\", \"transfer\", msg.sender, to, value, \"\");\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public override returns (bool) {\n        _revertOperation(\"transfer\", \"transferFrom\", from, to, value, \"\");\n    }\n\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _revertOperation(\"transfer\", \"approve\", msg.sender, spender, value, \"\");\n    }\n\n    function authorizeOperator(address operator) external override {\n        _revertOperation(\"change operator of\", \"authorizeOperator\", msg.sender, operator, 0, \"\");\n    }\n\n    function revokeOperator(address operator) external override {\n        _revertOperation(\"revoke operator of\", \"revokeOperator\", msg.sender, operator, 0, \"\");\n    }\n\n    // Private\n    function _revertOperation(\n        string memory action,\n        string memory operation,\n        address operator,\n        address recipient,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        emit ForbiddenOperation(operation, operator, recipient, amount, data);\n        revert(string.concat(\"Forbidden: Cannot \", action, \" \", name()));\n    }\n}\n"
    },
    "contracts/PenaltyToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.20;\n\nimport \"./NonTransferableERC777Token.sol\";\n\nabstract contract PenaltyToken is NonTransferableERC777Token {\n    constructor(\n        address[] memory defaultOperators\n    ) NonTransferableERC777Token(\"PenaltyToken\", \"PHBPE\", defaultOperators) {}\n}\n"
    },
    "contracts/ReputationToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./NonTransferableERC777Token.sol\";\r\n\r\ncontract ReputationToken is NonTransferableERC777Token {\r\n    constructor(\r\n        address[] memory defaultOperators\r\n    ) NonTransferableERC777Token(\"ReputationToken\", \"PHBRP\", defaultOperators) {}\r\n}\r\n"
    },
    "contracts/RewardToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./TransferableERC777Token.sol\";\r\n\r\ncontract RewardToken is TransferableERC777Token {\r\n    modifier memberOnly(address recipient) {\r\n        require(_memberCheck(recipient), \"Error: Recipient not a member\");\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address[] memory defaultOperators,\r\n        address _didRegistry,\r\n        address _claimsRegistry,\r\n        address _claimsIssuer\r\n    )\r\n        TransferableERC777Token(\r\n            \"RewardToken\",\r\n            \"PHBRW\",\r\n            defaultOperators,\r\n            _didRegistry,\r\n            _claimsRegistry,\r\n            _claimsIssuer\r\n        )\r\n    {}\r\n\r\n    // Restrict methods between member only\r\n    function send(\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public override memberOnly(recipient) {\r\n        super.send(recipient, amount, data);\r\n    }\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override memberOnly(recipient) returns (bool) {\r\n        return super.transfer(recipient, amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address holder,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override memberOnly(recipient) returns (bool) {\r\n        return super.transferFrom(holder, recipient, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/TokenClaimsIssuer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./EthereumClaimsRegistry.sol\";\r\n\r\ncontract TokenClaimsIssuer is Ownable {\r\n    // State variables\r\n    EthereumClaimsRegistry public claimRegistry;\r\n\r\n    bytes32 public constant MEMBERSHIP_CLAIM_KEY = keccak256(abi.encodePacked(\"membership\"));\r\n    bytes32 public constant MEMBERSHIP_CLAIM_VALUE = keccak256(abi.encodePacked(\"true\"));\r\n\r\n    // Events\r\n    event MembershipAdded(address indexed issuer, address indexed subject, uint256 updatedAt);\r\n\r\n    event MembershipRevoked(address indexed issuer, address indexed subject, uint256 removedAt);\r\n\r\n    event ClaimAdded(address indexed issuer, address indexed subject, bytes32 indexed key, bytes32 value, uint256 updatedAt);\r\n\r\n    event ClaimRemoved(address indexed issuer, address indexed subject, bytes32 indexed key, uint256 removedAt);\r\n\r\n\r\n    constructor(address _claimRegistry) Ownable(address(this)) {\r\n        claimRegistry = EthereumClaimsRegistry(_claimRegistry);\r\n    }\r\n\r\n    // External\r\n    function setMembershipClaim(address organization) external onlyOwner {\r\n        claimRegistry.setClaim(organization, MEMBERSHIP_CLAIM_KEY, MEMBERSHIP_CLAIM_VALUE);\r\n        emit MembershipAdded(msg.sender, organization, block.timestamp);\r\n    }\r\n\r\n    function revokeMembershipClaim(address organization) external onlyOwner {\r\n        claimRegistry.removeClaim(address(this), organization, MEMBERSHIP_CLAIM_KEY);\r\n        emit MembershipRevoked(msg.sender, organization, block.timestamp);\r\n    }\r\n\r\n    function setClaim(address subject, bytes32 key, bytes32 value) external onlyOwner {\r\n        claimRegistry.setClaim(subject, key, value);\r\n        emit ClaimAdded(msg.sender, subject, key, value, block.timestamp);\r\n    }\r\n\r\n    function removeClaim(address subject, bytes32 key) external onlyOwner {\r\n        claimRegistry.removeClaim(msg.sender, subject, key);\r\n        emit ClaimRemoved(msg.sender, subject, key, block.timestamp);\r\n    }\r\n\r\n    // Public\r\n\r\n    // Internal\r\n\r\n    // Private\r\n}\r\n"
    },
    "contracts/TokenOperator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./RewardToken.sol\";\nimport \"./PenaltyToken.sol\";\nimport \"./ReputationToken.sol\";\nimport \"./TokenClaimsIssuer.sol\";\nimport \"./EthereumDIDRegistry.sol\";\nimport \"./EthereumClaimsRegistry.sol\";\n\ncontract TokenOperator is Ownable {\n    RewardToken public rewardToken;\n    PenaltyToken public penaltyToken;\n    ReputationToken public reputationToken;\n    TokenClaimsIssuer public immutable claimsIssuer;\n    EthereumDIDRegistry public immutable didRegistry;\n    EthereumClaimsRegistry public immutable claimsRegistry;\n\n    // Events\n    event RewardsBurned(address indexed account, uint256 amount, bytes operatorData);\n    event PenaltiesBurned(address indexed account, uint256 amount, bytes operatorData);\n    event ReputationBurned(address indexed account, uint256 amount, bytes operatorData);\n\n    event RewardsMinted(address indexed account, uint256 amount, bytes operatorData);\n    event PenaltiesMinted(address indexed account, uint256 amount, bytes operatorData);\n    event ReputationMinted(address indexed account, uint256 amount, bytes operatorData);\n\n    event OrganizationNotMember(address organization);\n    event EmployeeNotRegistered(address organization, address account);\n    event BatchMintError(address organization, address account, uint256 amount);\n\n    constructor(\n        address _didRegistry,\n        address _claimsRegistry,\n        address _claimsIssuer\n    ) Ownable(msg.sender) {\n        didRegistry = EthereumDIDRegistry(_didRegistry);\n        claimsRegistry = EthereumClaimsRegistry(_claimsRegistry);\n        claimsIssuer = TokenClaimsIssuer(_claimsIssuer);\n    }\n\n    // External\n    function registerTokens(\n        address _rewardToken,\n        address _penaltyToken,\n        address _reputationToken\n    ) external onlyOwner {\n        rewardToken = RewardToken(_rewardToken);\n        penaltyToken = PenaltyToken(_penaltyToken);\n        reputationToken = ReputationToken(_reputationToken);\n    }\n\n    function balance(address account) external view returns (uint256, uint256, uint256) {\n        return (\n            rewardToken.balanceOf(account),\n            penaltyToken.balanceOf(account),\n            reputationToken.balanceOf(account)\n        );\n    }\n\n    function batchBurnTokens(address[] calldata _organization) external onlyOwner {\n        address[] calldata organization = _organization;\n        uint256 orgLength = organization.length;\n\n        for (uint256 i = 0; i < orgLength; i++) {\n            burnAll(organization[i]);\n        }\n    }\n\n    function batchMintPenalties(\n        address[] calldata _organizations,\n        address[] calldata _accounts,\n        uint256[] calldata _amounts\n    ) external onlyOwner {\n        uint256 orgLength = _organizations.length;\n        require(\n            orgLength == _accounts.length && orgLength == _amounts.length,\n            \"Error: Mismatched argument length\"\n        );\n\n        address[] calldata organizations = _organizations;\n        address[] calldata accounts = _accounts;\n        uint256[] calldata amounts = _amounts;\n\n        for (uint256 i = 0; i < orgLength; i++) {\n            address org = organizations[i];\n            address acc = accounts[i];\n            uint256 amount = amounts[i];\n\n            if (_memberCheck(org)) {\n                if (_employeeCheck(org, acc)) {\n                    mintPenalties(org, acc, amount, \"\");\n                } else {\n                    emit EmployeeNotRegistered(org, acc);\n                    emit BatchMintError(org, acc, amount);\n                }\n            } else {\n                emit OrganizationNotMember(org);\n                emit BatchMintError(org, acc, amount);\n            }\n        }\n    }\n\n    function batchMintReward(\n        address[] calldata _organizations,\n        address[] calldata _accounts,\n        uint256[] calldata _amounts\n    ) external onlyOwner {\n        uint256 orgLength = _organizations.length;\n        require(\n            orgLength == _accounts.length && orgLength == _amounts.length,\n            \"Error: Mismatched argument length\"\n        );\n\n        address[] calldata organizations = _organizations;\n        address[] calldata accounts = _accounts;\n        uint256[] calldata amounts = _amounts;\n\n        for (uint256 i = 0; i < orgLength; i++) {\n            address org = organizations[i];\n            address acc = accounts[i];\n            uint256 amount = amounts[i];\n\n            if (_memberCheck(org)) {\n                if (_employeeCheck(org, acc)) {\n                    mintReward(org, acc, amount, \"\");\n                } else {\n                    emit EmployeeNotRegistered(org, acc);\n                    emit BatchMintError(org, acc, amount);\n                }\n            } else {\n                emit OrganizationNotMember(org);\n                emit BatchMintError(org, acc, amount);\n            }\n        }\n    }\n\n    // Public\n    function burnAll(address organization) public onlyOwner {\n        burnRewards(organization, rewardToken.balanceOf(organization), \"membership renewal\");\n        burnPenalties(organization, penaltyToken.balanceOf(organization), \"membership renewal\");\n    }\n\n    function burnPenalties(\n        address account,\n        uint256 amount,\n        bytes memory operatorData\n    ) public onlyOwner {\n        penaltyToken.operatorBurn(account, amount, \"\", operatorData);\n        emit PenaltiesBurned(account, amount, operatorData);\n    }\n\n    function burnRewards(\n        address organization,\n        uint256 amount,\n        bytes memory operatorData\n    ) public onlyOwner {\n        rewardToken.operatorBurn(organization, amount, \"\", operatorData);\n        emit RewardsBurned(organization, amount, operatorData);\n    }\n\n    // Internal\n    function mintPenalties(\n        address organization,\n        address account,\n        uint256 amount,\n        bytes memory operatorData\n    ) internal {\n        penaltyToken.operatorMint(organization, amount, \"\", operatorData);\n\n        // Reduce user reputation balance\n        uint256 reputationValue = reputationToken.balanceOf(account);\n        uint256 penaltyReputation = reputationValue < amount ? reputationValue : amount;\n        reputationToken.operatorBurn(account, penaltyReputation, \"\", operatorData);\n\n        // Reduce org reputation balance\n        uint256 orgReputationValue = reputationToken.balanceOf(organization);\n        uint256 orgPenaltyReputation = orgReputationValue < amount ? orgReputationValue : amount;\n        reputationToken.operatorBurn(organization, orgPenaltyReputation, \"\", operatorData);\n\n        // Emit events\n        emit PenaltiesMinted(organization, amount, operatorData);\n        emit ReputationBurned(organization, amount, operatorData);\n        emit ReputationBurned(account, amount, operatorData);\n    }\n\n    function mintReward(\n        address organization,\n        address account,\n        uint256 amount,\n        bytes memory operatorData\n    ) internal {\n        // Increase user reputation balance\n        reputationToken.operatorMint(account, amount, \"\", operatorData);\n\n        // Increase org reputation & reward balance\n        rewardToken.operatorMint(organization, amount, \"\", operatorData);\n        reputationToken.operatorMint(organization, amount, \"\", operatorData);\n\n        emit RewardsMinted(organization, amount, operatorData);\n        emit ReputationMinted(organization, amount, operatorData);\n        emit ReputationMinted(account, amount, operatorData);\n    }\n\n    // Private\n    function _memberCheck(address organization) private view returns (bool) {\n        bytes32 isMember = claimsRegistry.getClaim(\n            address(claimsIssuer),\n            organization,\n            keccak256(abi.encodePacked(\"membership\"))\n        );\n\n        return isMember == keccak256(abi.encodePacked(\"membership\"));\n    }\n\n    function _employeeCheck(address organization, address account) private view returns (bool) {\n        return\n            didRegistry.validDelegate(\n                organization,\n                keccak256(abi.encodePacked(\"employee\")),\n                account\n            );\n    }\n}\n"
    },
    "contracts/TransferableERC777Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./ModifiedERC777.sol\";\r\nimport \"./EthereumClaimsRegistry.sol\";\r\nimport \"./EthereumDIDRegistry.sol\";\r\nimport \"./TokenClaimsIssuer.sol\";\r\n\r\nabstract contract TransferableERC777Token is ModifiedERC777 {\r\n    EthereumDIDRegistry public immutable didRegister;\r\n    EthereumClaimsRegistry public immutable claimsRegister;\r\n    TokenClaimsIssuer public immutable claimsIssuer;\r\n\r\n    constructor(\r\n        string memory tokenName,\r\n        string memory symbol,\r\n        address[] memory defaultOperators,\r\n        address _didRegister,\r\n        address _claimsRegister,\r\n        address _claimsIssuer\r\n    ) ModifiedERC777(tokenName, symbol, defaultOperators) {\r\n        didRegister = EthereumDIDRegistry(_didRegister);\r\n        claimsRegister = EthereumClaimsRegistry(_claimsRegister);\r\n        claimsIssuer = TokenClaimsIssuer(_claimsIssuer);\r\n    }\r\n\r\n    function _memberCheck(address member) internal view returns (bool) {\r\n        bytes32 claim = claimsRegister.getClaim(\r\n            address(claimsIssuer),\r\n            member,\r\n            keccak256(abi.encodePacked(\"membership\"))\r\n        );\r\n        return claim == keccak256(abi.encodePacked(\"true\"));\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nlibrary Address {\n    function isContract(address addr) internal view returns (bool) {\n        /**\n         * @notice Without EOA check, this method can be fooled\n         * See: https://ethereum.stackexchange.com/a/64340\n         *\n         * @dev EOA: Externally Owned Account\n         */\n        require(tx.origin == msg.sender, \"Not EOA\");\n\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n\n        return size > 0;\n    }\n\n    function isNotZeroAddress(address addr) internal pure returns (bool) {\n        return addr != address(0);\n    }\n}\n"
    },
    "contracts/WorkerOrderRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\ncontract WorkerOrderRegistry {\n    // contract code here\n}\n"
    },
    "contracts/WorkerRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.20;\n\ncontract WorkerRegistry {\n    // contract code here\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}